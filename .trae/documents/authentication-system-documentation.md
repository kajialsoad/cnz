# üîê ‡¶ï‡ßç‡¶≤‡¶ø‡¶® ‡¶ï‡ßá‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ - ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶Ö‡¶•‡ßá‡¶®‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®

## üìã ‡¶∏‡ßÇ‡¶ö‡¶ø‡¶™‡¶§‡ßç‡¶∞
1. [‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶ì‡¶≠‡¶æ‡¶∞‡¶≠‡¶ø‡¶â](#-‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ-‡¶ì‡¶≠‡¶æ‡¶∞‡¶≠‡¶ø‡¶â)
2. [‡¶Ö‡¶•‡ßá‡¶®‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶Ü‡¶∞‡ßç‡¶ï‡¶ø‡¶ü‡ßá‡¶ï‡¶ö‡¶æ‡¶∞](#-‡¶Ö‡¶•‡ßá‡¶®‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶®-‡¶Ü‡¶∞‡ßç‡¶ï‡¶ø‡¶ü‡ßá‡¶ï‡¶ö‡¶æ‡¶∞)
3. [‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶∞‡ßã‡¶≤ ‡¶è‡¶¨‡¶Ç ‡¶™‡¶æ‡¶∞‡¶Æ‡¶ø‡¶∂‡¶®](#-‡¶á‡¶â‡¶ú‡¶æ‡¶∞-‡¶∞‡ßã‡¶≤-‡¶è‡¶¨‡¶Ç-‡¶™‡¶æ‡¶∞‡¶Æ‡¶ø‡¶∂‡¶®)
4. [‡¶°‡ßá‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶∏‡ßç‡¶ï‡¶ø‡¶Æ‡¶æ](#-‡¶°‡ßá‡¶ü‡¶æ‡¶¨‡ßá‡¶∏-‡¶∏‡ßç‡¶ï‡¶ø‡¶Æ‡¶æ)
5. [API ‡¶è‡¶®‡ßç‡¶°‡¶™‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü‡¶∏](#-api-‡¶è‡¶®‡ßç‡¶°‡¶™‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü‡¶∏)
6. [Flutter ‡¶á‡¶Æ‡¶™‡ßç‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®](#-flutter-‡¶á‡¶Æ‡¶™‡ßç‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®)
7. [Node.js ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶è‡¶®‡ßç‡¶° ‡¶á‡¶Æ‡¶™‡ßç‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®](#-nodejs-‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶è‡¶®‡ßç‡¶°-‡¶á‡¶Æ‡¶™‡ßç‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®)
8. [‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∞‡¶ø‡¶ü‡¶ø ‡¶¨‡ßá‡¶∏‡ßç‡¶ü ‡¶™‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶ø‡¶∏](#-‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∞‡¶ø‡¶ü‡¶ø-‡¶¨‡ßá‡¶∏‡ßç‡¶ü-‡¶™‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶ø‡¶∏)
9. [‡¶è‡¶∞‡¶∞ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶ø‡¶Ç](#-‡¶è‡¶∞‡¶∞-‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶ø‡¶Ç)
10. [‡¶ü‡ßá‡¶∏‡ßç‡¶ü‡¶ø‡¶Ç ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ü‡ßá‡¶ú‡¶ø](#-‡¶ü‡ßá‡¶∏‡ßç‡¶ü‡¶ø‡¶Ç-‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ü‡ßá‡¶ú‡¶ø)

---

## üéØ ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶ì‡¶≠‡¶æ‡¶∞‡¶≠‡¶ø‡¶â

### ‡¶Ö‡¶•‡ßá‡¶®‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶´‡ßç‡¶≤‡ßã:
1. **‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶∞‡ßá‡¶ú‡¶ø‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡ßá‡¶∂‡¶®** (‡¶á‡¶Æ‡ßá‡¶á‡¶≤/‡¶´‡ßã‡¶® + ‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶°)
2. **‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶≤‡¶ó‡¶á‡¶®** JWT ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶ú‡ßá‡¶®‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶∏‡¶π
3. **‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶∞‡¶ø‡¶´‡ßç‡¶∞‡ßá‡¶∂ ‡¶Æ‡ßá‡¶ï‡¶æ‡¶®‡¶ø‡¶ú‡¶Æ**
4. **‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶° ‡¶∞‡¶ø‡¶∏‡ßá‡¶ü ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®‡¶æ‡¶≤‡¶ø‡¶ü‡¶ø**
5. **‡¶∏‡ßã‡¶∂‡¶æ‡¶≤ ‡¶≤‡¶ó‡¶á‡¶® ‡¶á‡¶®‡ßç‡¶ü‡¶ø‡¶ó‡ßç‡¶∞‡ßá‡¶∂‡¶®** (Google, Facebook)
6. **‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø-‡¶´‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶∞ ‡¶Ö‡¶•‡ßá‡¶®‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶®** (‡¶ê‡¶ö‡ßç‡¶õ‡¶ø‡¶ï)

### ‡¶ü‡ßá‡¶ï‡¶®‡ßã‡¶≤‡¶ú‡¶ø ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï:
- **Frontend**: Flutter (Dart)
- **Backend**: Node.js + Express.js + TypeScript
- **Database**: MySQL + Prisma ORM
- **Authentication**: JWT (JSON Web Tokens)
- **Token Storage**: flutter_secure_storage
- **Password Hashing**: bcrypt

---

## üèóÔ∏è ‡¶Ö‡¶•‡ßá‡¶®‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶Ü‡¶∞‡ßç‡¶ï‡¶ø‡¶ü‡ßá‡¶ï‡¶ö‡¶æ‡¶∞

```mermaid
graph TD
    A[Flutter App] --> B[API Gateway]
    B --> C[JWT Middleware]
    C --> D[Auth Controller]
    D --> E[Auth Service]
    E --> F[Database]
    
    G[Social Auth] --> B
    H[Email Service] --> E
    I[SMS Service] --> E
    
    subgraph "Frontend Layer"
        A
    end
    
    subgraph "Backend Layer"
        B --> C --> D --> E
    end
    
    subgraph "External Services"
        G
        H
        I
    end
    
    subgraph "Data Layer"
        F
    end
```

---

## üë• ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶∞‡ßã‡¶≤ ‡¶è‡¶¨‡¶Ç ‡¶™‡¶æ‡¶∞‡¶Æ‡¶ø‡¶∂‡¶®

### ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶∞‡ßã‡¶≤‡¶∏:

| ‡¶∞‡ßã‡¶≤ | ‡¶¨‡¶ø‡¶¨‡¶∞‡¶£ | ‡¶™‡¶æ‡¶∞‡¶Æ‡¶ø‡¶∂‡¶® |
|-----|--------|----------|
| **Customer** | ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ | ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏ ‡¶¨‡ßÅ‡¶ï ‡¶ï‡¶∞‡¶æ, ‡¶ï‡¶Æ‡¶™‡ßç‡¶≤‡ßá‡¶á‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞, ‡¶™‡ßá‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ |
| **Service Provider** | ‡¶ï‡ßç‡¶≤‡¶ø‡¶®‡¶æ‡¶∞/‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏ ‡¶™‡ßç‡¶∞‡ßã‡¶≠‡¶æ‡¶á‡¶°‡¶æ‡¶∞ | ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏ ‡¶Ö‡¶´‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ, ‡¶¨‡ßÅ‡¶ï‡¶ø‡¶Ç ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶ú ‡¶ï‡¶∞‡¶æ, ‡¶á‡¶®‡¶ï‡¶æ‡¶Æ ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶ï‡¶∞‡¶æ |
| **Admin** | ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® | ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶ú ‡¶ï‡¶∞‡¶æ, ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü ‡¶¶‡ßá‡¶ñ‡¶æ, ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® |
| **Super Admin** | ‡¶™‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶ü‡¶´‡¶∞‡ßç‡¶Æ ‡¶Æ‡¶æ‡¶≤‡¶ø‡¶ï | ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶è‡¶ï‡ßç‡¶∏‡ßá‡¶∏, ‡¶∏‡¶ï‡¶≤ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶´‡¶ø‡¶ö‡¶æ‡¶∞ |

### ‡¶™‡¶æ‡¶∞‡¶Æ‡¶ø‡¶∂‡¶® ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡ßç‡¶∞‡¶ø‡¶ï‡ßç‡¶∏:

```javascript
const permissions = {
  customer: ['book_service', 'view_profile', 'make_payment', 'submit_complaint'],
  serviceProvider: ['accept_booking', 'update_status', 'view_earnings', 'manage_schedule'],
  admin: ['manage_users', 'view_reports', 'manage_content', 'handle_complaints'],
  superAdmin: ['all_permissions']
};
```

---

## üíæ ‡¶°‡ßá‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶∏‡ßç‡¶ï‡¶ø‡¶Æ‡¶æ

### ‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶Æ‡¶æ ‡¶∏‡ßç‡¶ï‡¶ø‡¶Æ‡¶æ:

```prisma
// User model
model User {
  id                String           @id @default(uuid())
  email             String           @unique
  phone             String?          @unique
  password          String
  firstName         String
  lastName          String
  avatar            String?
  role              UserRole         @default(CUSTOMER)
  status            UserStatus       @default(ACTIVE)
  emailVerified     Boolean          @default(false)
  phoneVerified     Boolean          @default(false)
  twoFactorEnabled  Boolean          @default(false)
  twoFactorSecret   String?
  lastLoginAt       DateTime?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  
  // Relations
  sessions          Session[]
  refreshTokens     RefreshToken[]
  passwordResetTokens PasswordResetToken[]
  emailVerificationTokens EmailVerificationToken[]
  
  @@map("users")
}

// Session model
model Session {
  id          String   @id @default(uuid())
  userId      String
  token       String   @unique
  deviceInfo  String?
  ipAddress   String?
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("sessions")
}

// Refresh token model
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("refresh_tokens")
}

// Password reset token model
model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("password_reset_tokens")
}

// Email verification token model
model EmailVerificationToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("email_verification_tokens")
}

// Enums
enum UserRole {
  CUSTOMER
  SERVICE_PROVIDER
  ADMIN
  SUPER_ADMIN
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING
}
```

### MySQL ‡¶á‡¶®‡¶°‡ßá‡¶ï‡ßç‡¶∏:

```sql
-- User indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_phone ON users(phone);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_status ON users(status);

-- Token indexes
CREATE INDEX idx_sessions_token ON sessions(token);
CREATE INDEX idx_sessions_user_id ON sessions(userId);
CREATE INDEX idx_refresh_tokens_token ON refresh_tokens(token);
CREATE INDEX idx_password_reset_tokens_token ON password_reset_tokens(token);
CREATE INDEX idx_email_verification_tokens_token ON email_verification_tokens(token);
```

---

## üîå API ‡¶è‡¶®‡ßç‡¶°‡¶™‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü‡¶∏

### ‡¶Ö‡¶•‡ßá‡¶®‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶® API:

| ‡¶Æ‡ßá‡¶•‡¶° | ‡¶è‡¶®‡ßç‡¶°‡¶™‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü | ‡¶¨‡¶ø‡¶¨‡¶∞‡¶£ |
|-------|------------|--------|
| POST | `/api/auth/register` | ‡¶®‡¶§‡ßÅ‡¶® ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶∞‡ßá‡¶ú‡¶ø‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡ßá‡¶∂‡¶® |
| POST | `/api/auth/login` | ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶≤‡¶ó‡¶á‡¶® |
| POST | `/api/auth/logout` | ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶≤‡¶ó‡¶Ü‡¶â‡¶ü |
| POST | `/api/auth/refresh-token` | ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶∞‡¶ø‡¶´‡ßç‡¶∞‡ßá‡¶∂ |
| POST | `/api/auth/forgot-password` | ‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶° ‡¶∞‡¶ø‡¶∏‡ßá‡¶ü ‡¶∞‡¶ø‡¶ï‡ßã‡¶Ø‡¶º‡ßá‡¶∏‡ßç‡¶ü |
| POST | `/api/auth/reset-password` | ‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶° ‡¶∞‡¶ø‡¶∏‡ßá‡¶ü |
| POST | `/api/auth/verify-email` | ‡¶á‡¶Æ‡ßá‡¶á‡¶≤ ‡¶≠‡ßá‡¶∞‡¶ø‡¶´‡¶ø‡¶ï‡ßá‡¶∂‡¶® |
| GET | `/api/auth/profile` | ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡ßã‡¶´‡¶æ‡¶á‡¶≤ |
| PUT | `/api/auth/profile` | ‡¶™‡ßç‡¶∞‡ßã‡¶´‡¶æ‡¶á‡¶≤ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü |
| POST | `/api/auth/change-password` | ‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶° ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® |

### API ‡¶∞‡¶ø‡¶ï‡ßã‡¶Ø‡¶º‡ßá‡¶∏‡ßç‡¶ü/‡¶∞‡ßá‡¶∏‡¶™‡¶®‡ßç‡¶∏ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:

#### ‡¶∞‡ßá‡¶ú‡¶ø‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡ßá‡¶∂‡¶®:
```json
// Request
{
  "email": "user@example.com",
  "phone": "+8801234567890",
  "password": "SecurePass123!",
  "firstName": "John",
  "lastName": "Doe",
  "role": "CUSTOMER"
}

// Response
{
  "success": true,
  "message": "User registered successfully",
  "data": {
    "user": {
      "id": "uuid",
      "email": "user@example.com",
      "firstName": "John",
      "lastName": "Doe",
      "role": "CUSTOMER"
    },
    "token": "jwt_token_here",
    "refreshToken": "refresh_token_here"
  }
}
```

#### ‡¶≤‡¶ó‡¶á‡¶®:
```json
// Request
{
  "email": "user@example.com",
  "password": "SecurePass123!"
}

// Response
{
  "success": true,
  "data": {
    "user": {
      "id": "uuid",
      "email": "user@example.com",
      "firstName": "John",
      "lastName": "Doe",
      "role": "CUSTOMER",
      "avatar": "https://example.com/avatar.jpg"
    },
    "token": "jwt_token_here",
    "refreshToken": "refresh_token_here",
    "expiresIn": 3600
  }
}
```

---

## üì± Flutter ‡¶á‡¶Æ‡¶™‡ßç‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®

### ‡¶°‡¶ø‡¶™‡ßá‡¶®‡ßç‡¶°‡ßá‡¶®‡ßç‡¶∏‡¶ø:
```yaml
dependencies:
  flutter_secure_storage: ^8.0.0
  dio: ^5.3.0
  jwt_decoder: ^2.0.1
  provider: ^6.0.5
```

### ‡¶Ö‡¶•‡ßá‡¶®‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏:
```dart
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:dio/dio.dart';
import 'package:jwt_decoder/jwt_decoder.dart';

class AuthService {
  static const _storage = FlutterSecureStorage();
  static const _tokenKey = 'auth_token';
  static const _refreshTokenKey = 'refresh_token';
  static const _userKey = 'user_data';
  
  final Dio _dio = Dio(BaseOptions(
    baseUrl: 'https://api.cleancare.com',
    connectTimeout: const Duration(seconds: 30),
    receiveTimeout: const Duration(seconds: 30),
  ));

  // Token management
  Future<void> saveToken(String token) async {
    await _storage.write(key: _tokenKey, value: token);
  }

  Future<String?> getToken() async {
    return await _storage.read(key: _tokenKey);
  }

  Future<void> deleteToken() async {
    await _storage.delete(key: _tokenKey);
  }

  // Check if token is expired
  Future<bool> isTokenExpired() async {
    final token = await getToken();
    if (token == null) return true;
    
    return JwtDecoder.isExpired(token);
  }

  // Auto refresh token
  Future<void> refreshToken() async {
    try {
      final refreshToken = await _storage.read(key: _refreshTokenKey);
      if (refreshToken == null) throw Exception('No refresh token');

      final response = await _dio.post('/api/auth/refresh-token', data: {
        'refreshToken': refreshToken,
      });

      if (response.statusCode == 200) {
        await saveToken(response.data['data']['token']);
        await _storage.write(
          key: _refreshTokenKey,
          value: response.data['data']['refreshToken'],
        );
      }
    } catch (e) {
      await logout();
      throw Exception('Token refresh failed');
    }
  }

  // Login
  Future<Map<String, dynamic>> login({
    required String email,
    required String password,
  }) async {
    try {
      final response = await _dio.post('/api/auth/login', data: {
        'email': email,
        'password': password,
      });

      if (response.statusCode == 200) {
        final data = response.data['data'];
        
        await saveToken(data['token']);
        await _storage.write(key: _refreshTokenKey, value: data['refreshToken']);
        await _storage.write(key: _userKey, value: jsonEncode(data['user']));
        
        return data;
      }
      throw Exception('Login failed');
    } catch (e) {
      throw Exception('Login error: ${e.toString()}');
    }
  }

  // Register
  Future<Map<String, dynamic>> register({
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    try {
      final response = await _dio.post('/api/auth/register', data: {
        'email': email,
        'password': password,
        'firstName': firstName,
        'lastName': lastName,
        'phone': phone,
      });

      if (response.statusCode == 200) {
        final data = response.data['data'];
        
        await saveToken(data['token']);
        await _storage.write(key: _refreshTokenKey, value: data['refreshToken']);
        await _storage.write(key: _userKey, value: jsonEncode(data['user']));
        
        return data;
      }
      throw Exception('Registration failed');
    } catch (e) {
      throw Exception('Registration error: ${e.toString()}');
    }
  }

  // Logout
  Future<void> logout() async {
    try {
      final token = await getToken();
      if (token != null) {
        await _dio.post('/api/auth/logout',
          options: Options(headers: {'Authorization': 'Bearer $token'}),
        );
      }
    } catch (e) {
      // Silent logout
    } finally {
      await _storage.deleteAll();
    }
  }

  // Get current user
  Future<Map<String, dynamic>?> getCurrentUser() async {
    final userData = await _storage.read(key: _userKey);
    if (userData != null) {
      return jsonDecode(userData);
    }
    return null;
  }

  // Update profile
  Future<Map<String, dynamic>> updateProfile({
    String? firstName,
    String? lastName,
    String? phone,
    String? avatar,
  }) async {
    try {
      final token = await getToken();
      if (token == null) throw Exception('No authentication token');

      final response = await _dio.put('/api/auth/profile',
        data: {
          if (firstName != null) 'firstName': firstName,
          if (lastName != null) 'lastName': lastName,
          if (phone != null) 'phone': phone,
          if (avatar != null) 'avatar': avatar,
        },
        options: Options(headers: {'Authorization': 'Bearer $token'}),
      );

      if (response.statusCode == 200) {
        final data = response.data['data'];
        await _storage.write(key: _userKey, value: jsonEncode(data));
        return data;
      }
      throw Exception('Profile update failed');
    } catch (e) {
      throw Exception('Profile update error: ${e.toString()}');
    }
  }
}
```

### ‡¶Ö‡¶•‡ßá‡¶®‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶™‡ßç‡¶∞‡ßã‡¶≠‡¶æ‡¶á‡¶°‡¶æ‡¶∞:
```dart
import 'package:flutter/material.dart';
import 'auth_service.dart';

class AuthProvider with ChangeNotifier {
  final AuthService _authService = AuthService();
  Map<String, dynamic>? _user;
  bool _isLoading = false;
  String? _error;

  Map<String, dynamic>? get user => _user;
  bool get isLoading => _isLoading;
  String? get error => _error;
  bool get isAuthenticated => _user != null;

  Future<void> login({
    required String email,
    required String password,
  }) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final data = await _authService.login(
        email: email,
        password: password,
      );
      _user = data['user'];
      _error = null;
    } catch (e) {
      _error = e.toString();
      _user = null;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> register({
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final data = await _authService.register(
        email: email,
        password: password,
        firstName: firstName,
        lastName: lastName,
        phone: phone,
      );
      _user = data['user'];
      _error = null;
    } catch (e) {
      _error = e.toString();
      _user = null;
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> logout() async {
    await _authService.logout();
    _user = null;
    notifyListeners();
  }

  Future<void> loadUser() async {
    final userData = await _authService.getCurrentUser();
    if (userData != null) {
      _user = userData;
      notifyListeners();
    }
  }
}
```

### ‡¶≤‡¶ó‡¶á‡¶® ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶® ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:
```dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({Key? key}) : super(key: key);

  @override
  _LoginScreenState createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleLogin() async {
    if (_formKey.currentState!.validate()) {
      try {
        await Provider.of<AuthProvider>(context, listen: false).login(
          email: _emailController.text.trim(),
          password: _passwordController.text.trim(),
        );
        
        if (mounted) {
          Navigator.pushReplacementNamed(context, '/home');
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(e.toString())),
          );
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context);

    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                TextFormField(
                  controller: _emailController,
                  keyboardType: TextInputType.emailAddress,
                  decoration: const InputDecoration(
                    labelText: 'Email',
                    prefixIcon: Icon(Icons.email),
                    border: OutlineInputBorder(),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your email';
                    }
                    if (!value.contains('@')) {
                      return 'Please enter a valid email';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                TextFormField(
                  controller: _passwordController,
                  obscureText: _obscurePassword,
                  decoration: InputDecoration(
                    labelText: 'Password',
                    prefixIcon: const Icon(Icons.lock),
                    border: const OutlineInputBorder(),
                    suffixIcon: IconButton(
                      icon: Icon(_obscurePassword
                          ? Icons.visibility
                          : Icons.visibility_off),
                      onPressed: () {
                        setState(() {
                          _obscurePassword = !_obscurePassword;
                        });
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your password';
                    }
                    if (value.length < 6) {
                      return 'Password must be at least 6 characters';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 24),
                SizedBox(
                  width: double.infinity,
                  height: 48,
                  child: ElevatedButton(
                    onPressed: authProvider.isLoading ? null : _handleLogin,
                    child: authProvider.isLoading
                        ? const CircularProgressIndicator(color: Colors.white)
                        : const Text('Login'),
                  ),
                ),
                if (authProvider.error != null) ...[
                  const SizedBox(height: 16),
                  Text(
                    authProvider.error!,
                    style: const TextStyle(color: Colors.red),
                  ),
                ],
                TextButton(
                  onPressed: () {
                    Navigator.pushNamed(context, '/register');
                  },
                  child: const Text('Don\'t have an account? Register'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

---

## üíª Node.js ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶è‡¶®‡ßç‡¶° ‡¶á‡¶Æ‡¶™‡ßç‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®

### ‡¶Æ‡¶ø‡¶°‡¶≤‡¶ì‡¶Ø‡¶º‡ßç‡¶Ø‡¶æ‡¶∞:
```typescript
// middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export interface AuthRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: string;
  };
}

export const authenticateToken = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'Access token required'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
    
    // Check if user still exists and is active
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { id: true, email: true, role: true, status: true }
    });

    if (!user || user.status !== 'ACTIVE') {
      return res.status(401).json({
        success: false,
        message: 'User not found or inactive'
      });
    }

    req.user = user;
    next();
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      return res.status(401).json({
        success: false,
        message: 'Token expired'
      });
    }
    
    return res.status(403).json({
      success: false,
      message: 'Invalid token'
    });
  }
};

export const authorizeRole = (roles: string[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'Authentication required'
      });
    }

    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: 'Insufficient permissions'
      });
    }

    next();
  };
};
```

### ‡¶Ö‡¶•‡ßá‡¶®‡¶ü‡¶ø‡¶ï‡ßá‡¶∂‡¶® ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤‡¶æ‡¶∞:
```typescript
// controllers/auth.controller.ts
import { Request, Response } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { PrismaClient } from '@prisma/client';
import { AuthRequest } from '../middleware/auth.middleware';

const prisma = new PrismaClient();

export class AuthController {
  // Register
  async register(req: Request, res: Response) {
    try {
      const { email, phone, password, firstName, lastName, role } = req.body;

      // Validate input
      if (!email || !password || !firstName || !lastName) {
        return res.status(400).json({
          success: false,
          message: 'Missing required fields'
        });
      }

      // Check if user exists
      const existingUser = await prisma.user.findFirst({
        where: {
          OR: [
            { email },
            ...(phone ? [{ phone }] : [])
          ]
        }
      });

      if (existingUser) {
        return res.status(409).json({
          success: false,
          message: 'User already exists'
        });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(password, 12);

      // Create user
      const user = await prisma.user.create({
        data: {
          email,
          phone,
          password: hashedPassword,
          firstName,
          lastName,
          role: role || 'CUSTOMER'
        },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          role: true,
          avatar: true
        }
      });

      // Generate tokens
      const token = this.generateToken(user.id);
      const refreshToken = this.generateRefreshToken(user.id);

      // Store refresh token
      await prisma.refreshToken.create({
        data: {
          userId: user.id,
          token: refreshToken,
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
        }
      });

      // Send verification email (async)
      this.sendVerificationEmail(user.id, email);

      res.status(201).json({
        success: true,
        message: 'User registered successfully',
        data: {
          user,
          token,
          refreshToken
        }
      });
    } catch (error) {
      console.error('Registration error:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  }

  // Login
  async login(req: Request, res: Response) {
    try {
      const { email, password } = req.body;

      // Validate input
      if (!email || !password) {
        return res.status(400).json({
          success: false,
          message: 'Email and password are required'
        });
      }

      // Find user
      const user = await prisma.user.findUnique({
        where: { email }
      });

      if (!user) {
        return res.status(401).json({
          success: false,
          message: 'Invalid credentials'
        });
      }

      // Check password
      const isPasswordValid = await bcrypt.compare(password, user.password);
      if (!isPasswordValid) {
        return res.status(401).json({
          success: false,
          message: 'Invalid credentials'
        });
      }

      // Check user status
      if (user.status !== 'ACTIVE') {
        return res.status(401).json({
          success: false,
          message: 'Account is not active'
        });
      }

      // Generate tokens
      const token = this.generateToken(user.id);
      const refreshToken = this.generateRefreshToken(user.id);

      // Store refresh token
      await prisma.refreshToken.create({
        data: {
          userId: user.id,
          token: refreshToken,
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
        }
      });

      // Update last login
      await prisma.user.update({
        where: { id: user.id },
        data: { lastLoginAt: new Date() }
      });

      // Create session
      await prisma.session.create({
        data: {
          userId: user.id,
          token,
          deviceInfo: req.headers['user-agent'],
          ipAddress: req.ip,
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours
        }
      });

      res.json({
        success: true,
        data: {
          user: {
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            avatar: user.avatar
          },
          token,
          refreshToken,
          expiresIn: 3600
        }
      });
    } catch (error) {
      console.error('Login error:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  }

  // Logout
  async logout(req: AuthRequest, res: Response) {
    try {
      const token = req.headers.authorization?.split(' ')[1];
      
      if (token && req.user) {
        // Delete session
        await prisma.session.deleteMany({
          where: { token }
        });

        // Delete refresh token
        await prisma.refreshToken.deleteMany({
          where: { userId: req.user.id }
        });
      }

      res.json({
        success: true,
        message: 'Logged out successfully'
      });
    } catch (error) {
      console.error('Logout error:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  }

  // Refresh token
  async refreshToken(req: Request, res: Response) {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        return res.status(400).json({
          success: false,
          message: 'Refresh token is required'
        });
      }

      // Find refresh token
      const tokenRecord = await prisma.refreshToken.findUnique({
        where: { token: refreshToken }
      });

      if (!tokenRecord || tokenRecord.expiresAt < new Date()) {
        return res.status(401).json({
          success: false,
          message: 'Invalid or expired refresh token'
        });
      }

      // Find user
      const user = await prisma.user.findUnique({
        where: { id: tokenRecord.userId },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          role: true,
          avatar: true,
          status: true
        }
      });

      if (!user || user.status !== 'ACTIVE') {
        return res.status(401).json({
          success: false,
          message: 'User not found or inactive'
        });
      }

      // Generate new tokens
      const newToken = this.generateToken(user.id);
      const newRefreshToken = this.generateRefreshToken(user.id);

      // Delete old refresh token
      await prisma.refreshToken.delete({
        where: { id: tokenRecord.id }
      });

      // Store new refresh token
      await prisma.refreshToken.create({
        data: {
          userId: user.id,
          token: newRefreshToken,
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
        }
      });

      res.json({
        success: true,
        data: {
          user,
          token: newToken,
          refreshToken: newRefreshToken
        }
      });
    } catch (error) {
      console.error('Refresh token error:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  }

  // Profile
  async getProfile(req: AuthRequest, res: Response) {
    try {
      if (!req.user) {
        return res.status(401).json({
          success: false,
          message: 'Authentication required'
        });
      }

      const user = await prisma.user.findUnique({
        where: { id: req.user.id },
        select: {
          id: true,
          email: true,
          phone: true,
          firstName: true,
          lastName: true,
          role: true,
          avatar: true,
          emailVerified: true,
          phoneVerified: true,
          twoFactorEnabled: true,
          createdAt: true,
          lastLoginAt: true
        }
      });

      if (!user) {
        return res.status(404).json({
          success: false,
          message: 'User not found'
        });
      }

      res.json({
        success: true,
        data: user
      });
    } catch (error) {
      console.error('Get profile error:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  }

  // Update profile
  async updateProfile(req: AuthRequest, res: Response) {
    try {
      if (!req.user) {
        return res.status(401).json({
          success: false,
          message: 'Authentication required'
        });
      }

      const { firstName, lastName, phone, avatar } = req.body;

      const updatedUser = await prisma.user.update({
        where: { id: req.user.id },
        data: {
          ...(firstName && { firstName }),
          ...(lastName && { lastName }),
          ...(phone && { phone }),
          ...(avatar && { avatar })
        },
        select: {
          id: true,
          email: true,
          phone: true,
          firstName: true,
          lastName: true,
          role: true,
          avatar: true
        }
      });

      res.json({
        success: true,
        data: updatedUser
      });
    } catch (error) {
      console.error('Update profile error:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  }

  // Helper methods
  private generateToken(userId: string): string {
    return jwt.sign(
      { userId },
      process.env.JWT_SECRET!,
      { expiresIn: '1h' }
    );
  }

  private generateRefreshToken(userId: string): string {
    return jwt.sign(
      { userId, type: 'refresh' },
      process.env.JWT_REFRESH_SECRET!,
      { expiresIn: '7d' }
    );
  }

  private async sendVerificationEmail(userId: string, email: string) {
    // Implementation for sending verification email
    // This should be async and not block the response
  }
}
```

---

## üîí ‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∞‡¶ø‡¶ü‡¶ø ‡¶¨‡ßá‡¶∏‡ßç‡¶ü ‡¶™‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶ø‡¶∏

### 1. ‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶° ‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∞‡¶ø‡¶ü‡¶ø:
```typescript
// Password validation
const passwordSchema = {
  minLength: 8,
  maxLength: 128,
  requireUppercase: true,
  requireLowercase: true,
  requireNumbers: true,
  requireSpecialChars: true,
  preventCommonPasswords: true
};

// Bcrypt configuration
const SALT_ROUNDS = 12;
const hashedPassword = await bcrypt.hash(password, SALT_ROUNDS);
```

### 2. JWT ‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∞‡¶ø‡¶ü‡¶ø:
```typescript
// JWT configuration
const JWT_CONFIG = {
  secret: process.env.JWT_SECRET, // 256-bit secret key
  expiresIn: '1h', // Short expiration time
  issuer: 'cleancare.app',
  audience: 'cleancare-users'
};

// Refresh token rotation
const refreshTokenRotation = true;
const refreshTokenExpiresIn = '7d';
```

### 3. Rate Limiting:
```typescript
import rateLimit from 'express-rate-limit';

const loginRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: 'Too many login attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

const registrationRateLimit = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 3, // limit each IP to 3 requests per windowMs
  message: 'Too many registration attempts, please try again later'
});
```

### 4. CORS Configuration:
```typescript
import cors from 'cors';

const corsOptions = {
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
};

app.use(cors(corsOptions));
```

### 5. Security Headers:
```typescript
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));
```

---

## ‚ö†Ô∏è ‡¶è‡¶∞‡¶∞ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶ø‡¶Ç

### ‡¶ï‡¶Æ‡¶® ‡¶è‡¶∞‡¶∞ ‡¶ï‡ßã‡¶°:

| ‡¶ï‡ßã‡¶° | ‡¶¨‡¶ø‡¶¨‡¶∞‡¶£ | ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® |
|-----|--------|---------|
| **400** | Bad Request | ‡¶á‡¶®‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡¶ø‡¶° ‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‡¶°‡ßá‡¶ü‡¶æ |
| **401** | Unauthorized | ‡¶á‡¶®‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡¶ø‡¶° ‡¶ï‡ßç‡¶∞‡ßá‡¶°‡ßá‡¶®‡¶∂‡¶ø‡¶Ø‡¶º‡¶æ‡¶≤‡¶∏ |
| **403** | Forbidden | ‡¶á‡¶®‡¶∏‡¶æ‡¶´‡¶ø‡¶∂‡¶ø‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü ‡¶™‡¶æ‡¶∞‡¶Æ‡¶ø‡¶∂‡¶® |
| **404** | Not Found | ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶®‡¶ü ‡¶´‡¶æ‡¶â‡¶®‡ßç‡¶° |
| **409** | Conflict | ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Ü‡¶≤‡¶∞‡ßá‡¶°‡¶ø ‡¶è‡¶ï‡ßç‡¶∏‡¶ø‡¶∏‡ßç‡¶ü |
| **429** | Too Many Requests | ‡¶∞‡ßá‡¶ü ‡¶≤‡¶ø‡¶Æ‡¶ø‡¶ü ‡¶è‡¶ï‡ßç‡¶∏‡¶ø‡¶∏‡¶° |
| **500** | Internal Server Error | ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶è‡¶∞‡¶∞ |

### ‡¶è‡¶∞‡¶∞ ‡¶∞‡ßá‡¶∏‡¶™‡¶®‡ßç‡¶∏ ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü:
```json
{
  "success": false,
  "error": {
    "code": "AUTH_INVALID_CREDENTIALS",
    "message": "Invalid email or password",
    "details": {
      "field": "password",
      "reason": "incorrect_password"
    }
  },
  "timestamp": "2024-01-01T00:00:00.000Z"
}
```

---

## üß™ ‡¶ü‡ßá‡¶∏‡ßç‡¶ü‡¶ø‡¶Ç ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ü‡ßá‡¶ú‡¶ø

### 1. ‡¶á‡¶â‡¶®‡¶ø‡¶ü ‡¶ü‡ßá‡¶∏‡ßç‡¶ü‡¶ø‡¶Ç:
```typescript
// tests/auth.test.ts
import { AuthController } from '../controllers/auth.controller';
import { PrismaClient } from '@prisma/client';

const authController = new AuthController();

describe('AuthController', () => {
  describe('register', () => {
    it('should register a new user successfully', async () => {
      const req = {
        body: {
          email: 'test@example.com',
          password: 'SecurePass123!',
          firstName: 'Test',
          lastName: 'User'
        }
      };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };

      await authController.register(req, res);

      expect(res.status).toHaveBeenCalledWith(201);
      expect(res.json).toHaveBeenCalledWith(
        expect.objectContaining({
          success: true,
          message: 'User registered successfully'
        })
      );
    });

    it('should return error for duplicate email', async () => {
      const req = {
        body: {
          email: 'existing@example.com',
          password: 'SecurePass123!',
          firstName: 'Test',
          lastName: 'User'
        }
      };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };

      await authController.register(req, res);

      expect(res.status).toHaveBeenCalledWith(409);
      expect(res.json).toHaveBeenCalledWith(
        expect.objectContaining({
          success: false,
          message: 'User already exists'
        })
      );
    });
  });
});
```

### 2. ‡¶á‡¶®‡ßç‡¶ü‡¶ø‡¶ó‡ßç‡¶∞‡ßá‡¶∂‡¶® ‡¶ü‡ßá‡¶∏‡ßç‡¶ü‡¶ø‡¶Ç:
```typescript
// tests/integration/auth.integration.test.ts
import request from 'supertest';
import app from '../../src/app';

describe('Auth API Integration', () => {
  describe('POST /api/auth/register', () => {
    it('should create a new user', async () => {
      const response = await request(app)
        .post('/api/auth/register')
        .send({
          email: 'newuser@example.com',
          password: 'SecurePass123!',
          firstName: 'New',
          lastName: 'User'
        });

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data.user).toHaveProperty('id');
      expect(response.body.data).toHaveProperty('token');
    });
  });

  describe('POST /api/auth/login', () => {
    it('should login with valid credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'SecurePass123!'
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('token');
      expect(response.body.data.user.email).toBe('test@example.com');
    });
  });
});
```

### 3. Flutter ‡¶â‡¶á‡¶ú‡ßá‡¶ü ‡¶ü‡ßá‡¶∏‡ßç‡¶ü‡¶ø‡¶Ç:
```dart
// test/auth_widget_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:provider/provider.dart';
import 'package:clean_care/pages/login_page.dart';
import 'package:clean_care/providers/auth_provider.dart';

void main() {
  testWidgets('Login form validation', (WidgetTester tester) async {
    await tester.pumpWidget(
      ChangeNotifierProvider(
        create: (_) => AuthProvider(),
        child: const MaterialApp(home: LoginScreen()),
      ),
    );

    // Test empty form submission
    await tester.tap(find.byType(ElevatedButton));
    await tester.pump();

    expect(find.text('Please enter your email'), findsOneWidget);
    expect(find.text('Please enter your password'), findsOneWidget);

    // Test invalid email
    await tester.enterText(find.byType(TextFormField).first, 'invalid-email');
    await tester.tap(find.byType(ElevatedButton));
    await tester.pump();

    expect(find.text('Please enter a valid email'), findsOneWidget);
  });
}
```

---

## üîß ‡¶è‡¶®‡¶≠‡¶æ‡¶Ø‡¶º‡¶∞‡¶®‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶≠‡ßá‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶¨‡¶≤

### .env.example:
```bash
# Server Configuration
NODE_ENV=development
PORT=3000
FRONTEND_URL=http://localhost:3000

# Database
DATABASE_URL="mysql://user:password@localhost:3306/clean_care_db"

# JWT Secrets
JWT_SECRET=your-super-secret-jwt-key-here-minimum-256-bits
JWT_REFRESH_SECRET=your-refresh-token-secret-here-also-256-bits

# Email Service
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password

# SMS Service (Optional)
SMS_API_KEY=your-sms-api-key
SMS_API_SECRET=your-sms-api-secret

# File Upload
AWS_ACCESS_KEY_ID=your-aws-access-key
AWS_SECRET_ACCESS_KEY=your-aws-secret-key
AWS_REGION=your-region
AWS_S3_BUCKET=your-s3-bucket

# Social Auth (Optional)
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
FACEBOOK_APP_ID=your-facebook-app-id
FACEBOOK_APP_SECRET=your-facebook-app-secret
```

---

## üìã ‡¶°‡¶ø‡¶™‡ßç‡¶≤‡¶Ø‡¶º‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ö‡ßá‡¶ï‡¶≤‡¶ø‡¶∏‡ßç‡¶ü

### ‡¶™‡ßç‡¶∞‡¶ø-‡¶°‡¶ø‡¶™‡ßç‡¶≤‡¶Ø‡¶º‡¶Æ‡ßá‡¶®‡ßç‡¶ü:
- [ ] ‡¶∏‡¶¨ ‡¶ü‡ßá‡¶∏‡ßç‡¶ü ‡¶™‡¶æ‡¶∏ ‡¶ï‡¶∞‡¶æ
- [ ] ‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∞‡¶ø‡¶ü‡¶ø ‡¶Ö‡¶°‡¶ø‡¶ü ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®
- [ ] ‡¶è‡¶®‡¶≠‡¶æ‡¶Ø‡¶º‡¶∞‡¶®‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶≠‡ßá‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶¨‡¶≤ ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ
- [ ] ‡¶°‡ßá‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶Æ‡¶æ‡¶á‡¶ó‡ßç‡¶∞‡ßá‡¶∂‡¶® ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ
- [ ] ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶Ü‡¶™ ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ

### ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡¶∂‡¶® ‡¶°‡¶ø‡¶™‡ßç‡¶≤‡¶Ø‡¶º‡¶Æ‡ßá‡¶®‡ßç‡¶ü:
- [ ] HTTPS ‡¶á‡¶®‡ßá‡¶¨‡¶≤ ‡¶ï‡¶∞‡¶æ
- [ ] ‡¶∞‡ßá‡¶ü ‡¶≤‡¶ø‡¶Æ‡¶ø‡¶ü‡¶ø‡¶Ç ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡¶ø‡¶≠ ‡¶ï‡¶∞‡¶æ
- [ ] ‡¶Æ‡¶®‡¶ø‡¶ü‡¶∞‡¶ø‡¶Ç ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ‡¶ï‡¶∞‡¶æ
- [ ] ‡¶≤‡¶ó‡¶ø‡¶Ç ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ
- [ ] ‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∞‡¶ø‡¶ü‡¶ø ‡¶π‡ßá‡¶°‡¶æ‡¶∞‡¶∏ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ

---

## üîó ‡¶∞‡ßá‡¶´‡¶æ‡¶∞‡ßá‡¶®‡ßç‡¶∏

### Flutter ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ú:
- [flutter_secure_storage](https://pub.dev/packages/flutter_secure_storage)
- [dio](https://pub.dev/packages/dio)
- [jwt_decoder](https://pub.dev/packages/jwt_decoder)
- [provider](https://pub.dev/packages/provider)

### Node.js ‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡¶ø:
- [jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken)
- [bcrypt](https://www.npmjs.com/package/bcrypt)
- [express-rate-limit](https://www.npmjs.com/package/express-rate-limit)
- [helmet](https://www.npmjs.com/package/helmet)
- [cors](https://www.npmjs.com/package/cors)

### ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®:
- [JWT.io](https://jwt.io/)
- [Prisma Documentation](https://www.prisma.io/docs/)
- [Flutter Documentation](https://flutter.dev/docs)
- [Express.js Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html)

---

## üìû ‡¶∏‡¶æ‡¶™‡ßã‡¶∞‡ßç‡¶ü

‡¶™‡ßç‡¶∞‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§‡¶ø‡¶ó‡¶§ ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶§‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø:
- ‡¶á‡¶Æ‡ßá‡¶á‡¶≤: tech-support@cleancare.com
- ‡¶´‡ßã‡¶®: +8801234567890
- ‡¶ü‡¶ø‡¶ï‡ßá‡¶ü ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ: https://support.cleancare.com

---

**¬© 2024 ‡¶ï‡ßç‡¶≤‡¶ø‡¶® ‡¶ï‡ßá‡¶Ø‡¶º‡¶æ‡¶∞. ‡¶∏‡¶∞‡ßç‡¶¨‡¶∏‡ßç‡¶¨‡¶§‡ßç‡¶¨ ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶ø‡¶§.**